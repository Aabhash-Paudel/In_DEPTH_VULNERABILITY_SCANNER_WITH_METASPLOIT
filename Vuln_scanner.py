#!/usr/bin/python3
'''
    In-depth Network Vulnerability Scanner with Metasploit integration. 
    ( NMAP is also used for better performance)
'''

import sys
import re
import csv
import logging
import time
import argparse
import nmap
import requests
import concurrent.futures
import os
import subprocess
from pymetasploit3.msfrpc import MsfRpcClient
import colorama
from art import text2art

MSF_PASSWD = "aashu22"  # Set your Metasploit RPC password
LOG_FILE_PATH = '/var/log/custom_nmap_metasploit.log'

logging.basicConfig(filename=LOG_FILE_PATH, format='%(asctime)s:%(levelname)s:%(message)s', level=logging.INFO)

colorama.init()

# Argument Parser
try:
    PARSER = argparse.ArgumentParser()
    PARSER.add_argument('-i', metavar='input_file', required=True, type=str, help='Input file containing subnets or IPs')
    PARSER.add_argument('-l', metavar='module_file', required=True, type=str, help='Input CSV file containing module details')
    PARSER.add_argument('-o', metavar='output_file', required=True, type=str, help='Output file to store results')
    PARSER.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    ARGS = PARSER.parse_args()
except ImportError:
    print('Missing required modules: argparse, nmap, pymetasploit3')
    sys.exit(1)

def print_output(message, level='info', always_print=False):
    if ARGS.verbose or always_print:
        if level == 'info':
            print(colorama.Fore.BLUE + "[*] " + colorama.Fore.RESET + message)
        elif level == 'success':
            print(colorama.Fore.GREEN + "[+] " + colorama.Fore.RESET + message)
        elif level == 'warning':
            print(colorama.Fore.YELLOW + "[!] " + colorama.Fore.RESET + message)
        elif level == 'error':
            print(colorama.Fore.RED + "[-] " + colorama.Fore.RESET + message)

def is_ip_reachable(ip):
    '''
    Function to check if an IP address is reachable via ping
    '''
    try:
        output = subprocess.run(["ping", "-c", "1", ip], stdout=subprocess.PIPE)
        if output.returncode == 0:
            print_output(f"IP {ip} is reachable.", level='success')
            logging.info(f"IP {ip} is reachable.")
            return True
        else:
            print_output(f"IP {ip} is not reachable.", level='warning')
            logging.warning(f"IP {ip} is not reachable.")
            return False
    except Exception as e:
        print_output(f"Error pinging IP {ip}: {e}", level='error')
        logging.error(f"Error pinging IP {ip}: {e}")
        return False

# Initialize Metasploit RPC client
try:
    print_output("Connecting to Metasploit RPC...", always_print=True)
    GLOBAL_C = MsfRpcClient(MSF_PASSWD, server='127.0.0.1', port=55553)  # Adjust the port as per your configuration
    print_output("Connected to Metasploit RPC.", level='success', always_print=True)
except Exception as e:
    logging.error(f"Error connecting to Metasploit RPC: {e}")
    print_output(f"Error connecting to Metasploit RPC: {e}", level='error', always_print=True)
    sys.exit(1)

def check_db_connection():
    '''
    Check if Metasploit database is connected.
    '''
    try:
        console_id = GLOBAL_C.consoles.console().cid
        GLOBAL_C.consoles.console(console_id).write('db_status')
        
        # Wait for the command to complete
        busy = True
        start_time = time.time()
        while busy and time.time() - start_time < 10:  # 10 second timeout
            busy = GLOBAL_C.consoles.console(console_id).is_busy()
            if not busy:
                break
            time.sleep(0.5)
        
        if busy:
            print_output("Timeout waiting for db_status command to complete", level='error')
            return False
        
        output = GLOBAL_C.consoles.console(console_id).read()
        print_output(f"Full db_status output: {output}")
        
        # Check if we need to issue the command again
        if "metasploit v" in output['data'].lower():
            print_output("Received banner instead of db_status. Trying again...", level='warning')
            GLOBAL_C.consoles.console(console_id).write('db_status')
            time.sleep(2)
            output = GLOBAL_C.consoles.console(console_id).read()
            print_output(f"Second db_status attempt output: {output}")
        
        if "connected" in output['data'].lower() and "postgresql" in output['data'].lower():
            print_output("Metasploit DB connected.", level='success')
            return True
        else:
            print_output("Metasploit DB not connected.", level='error')
            return False
    except Exception as e:
        print_output(f"Error checking Metasploit DB connection: {e}", level='error')
        return False

def msf_init():
    print_output("Initializing Metasploit console...", always_print=True)
    local_console_number = GLOBAL_C.consoles.console().cid
    busy_value = GLOBAL_C.consoles.console(local_console_number).is_busy()
    while busy_value:
        busy_value = GLOBAL_C.consoles.console(local_console_number).is_busy()
    console_output = GLOBAL_C.consoles.console(local_console_number).read()
    while not console_output['data']:
        console_output = GLOBAL_C.consoles.console(local_console_number).read()

    # Check database connection
    GLOBAL_C.consoles.console(local_console_number).write('db_status')
    time.sleep(2)  # Give it a moment to process
    busy_value = GLOBAL_C.consoles.console(local_console_number).is_busy()
    while busy_value:
        busy_value = GLOBAL_C.consoles.console(local_console_number).is_busy()
    console_output = GLOBAL_C.consoles.console(local_console_number).read()

    print_output(f"Raw console output: {console_output}")  # Debug print

    if "Connected to msf" in str(console_output):
        logging.info("Metasploit DB connected.")
        print_output("Metasploit DB connected.", level='success')
    else:
        logging.error(f"Metasploit DB not connected. Console output: {console_output}")
        print_output(f"Metasploit DB not connected. Console output: {console_output}", level='error')
        
        # Try to reconnect to the database
        GLOBAL_C.consoles.console(local_console_number).write('db_connect')
        time.sleep(2)
        busy_value = GLOBAL_C.consoles.console(local_console_number).is_busy()
        while busy_value:
            busy_value = GLOBAL_C.consoles.console(local_console_number).is_busy()
        console_output = GLOBAL_C.consoles.console(local_console_number).read()
        
        print_output(f"Reconnection attempt output: {console_output}")  # Debug print
        
        if "Connected to msf" in str(console_output):
            logging.info("Metasploit DB connected after reconnection attempt.")
            print_output("Metasploit DB connected after reconnection attempt.", level='success')
        else:
            logging.error("Metasploit DB connection failed after reconnection attempt.")
            print_output("Metasploit DB connection failed after reconnection attempt.", level='error')
            sys.exit(1)

    return local_console_number

GLOBAL_CONSOLE_NUMBER = msf_init()

class SMBHost:
    '''
    Class to hold parsed information from SMB scans.
    '''
    def __init__(self, data):
        self.local_ip = data
        self.computer_os = ""
        self.computer_name = ""
        self.computer_domain = ""
        self.workgroup_host = ""
        self.os_cpe = ""

    def add_os(self, data):
        self.computer_os = data

    def add_computer_name(self, data):
        self.computer_name = data

    def add_domain(self, data):
        self.computer_domain = data

    def add_workgroup(self, data):
        self.workgroup_host = data

    def add_cpe(self, data):
        self.os_cpe = data

def smb_info_parser(host_ip, nm2):
    print_output(f"Parsing SMB information for {host_ip}...")

    try:
        if nm2[host_ip].state() != "up":
            print_output(f"Host {host_ip} is not up, skipping SMB information parsing.", level='warning')
            return None

        output_list = []
        network_class = SMBHost(host_ip)
        output_list.append(network_class)

        if 'hostscript' not in nm2._scan_result['scan'][host_ip]:
            print_output(f"No 'hostscript' data available for {host_ip}", level='warning')
            return output_list

        local_scan_results = nm2._scan_result['scan'][host_ip]['hostscript']

        for local_output in local_scan_results:
            if local_output['id'] == "smb-os-discovery":
                for attr, regex_pattern in [
                    ('computer_os', '(?<=OS:).*'),
                    ('computer_name', '(?<=Computer name:).*'),
                    ('workgroup_host', '(?<=Workgroup:).*'),
                    ('computer_domain', '(?<=Domain name:).*'),
                    ('os_cpe', '(?<=OS CPE:).*')
                ]:
                    regex = re.compile(regex_pattern)
                    match = regex.search(local_output['output'])
                    if match:
                        setattr(network_class, attr, match.group().strip())

        return output_list

    except KeyError as e:
        print_output(f"KeyError in smb_info_parser: {e}", level='error')
        print_output(f"nm2 scan result: {nm2._scan_result}")
        return None
    except Exception as e:
        print_output(f"Error in smb_info_parser: {e}", level='error')
        return None

def vuln_check(vuln):
    print_output(f"Checking vulnerability: {vuln[2]} with module: {vuln[1]}")

    # Check if the IP address is up before performing the vulnerability check
    nm = nmap.PortScanner()
    nm.scan(hosts=vuln[0], arguments='-sn')
    if nm[vuln[0]].state() != "up":
        print_output(f"Host {vuln[0]} is not up, skipping vulnerability check.", level='warning')
        return

    GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).write(f'search path:{vuln[1]} type:aux')
    time.sleep(2)
    busy_value = GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).is_busy()
    while busy_value:
        busy_value = GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).is_busy()
    console_output = GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).read()

    if vuln[2] in console_output['data']:
        print_output(f"Found {vuln[2]} with {vuln[1]}", level='success')
        GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).write(f'use {vuln[1]}')
        time.sleep(1)
        GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).write(f'set RHOSTS {vuln[0]}')
        time.sleep(1)
        GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).write(f'run')
        time.sleep(1)
        busy_value = GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).is_busy()
        while busy_value:
            busy_value = GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).is_busy()
        output = GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).read()
        print_output(f"Output for {vuln[2]}: {output['data']}")
        return output['data']
    else:
        print_output(f"Vulnerability {vuln[2]} not found with module {vuln[1]}", level='warning')

def msf_scan(ip_to_check, row_i):
    ip_to_check_str = str(ip_to_check)
    print_output(f"Starting Metasploit scan for {ip_to_check_str} ...")
    try:
        if len(row_i) < 3:
            print_output(f"Insufficient data in module row: {row_i}", level='error')
            return "error: insufficient module data"

        GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).write(f'use {row_i[1]}')
        GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).write(f'set rport {row_i[0]}')
        GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).write(f'set rhosts {ip_to_check}')

        scan_end = True
        scan_end_int = 0
        while scan_end and scan_end_int < 900:
            local_output = GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).read()
            if ip_to_check in str(local_output):
                scan_end = False
            time.sleep(1)
            scan_end_int += 1

        if scan_end_int >= 900:
            logging.error(f"Timeout while setting rhosts: {ip_to_check_str}")
            return "error: timeout setting rhosts"

        GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).write('run')
        
        timeout = time.time() + 300  # 5 minutes from now
        while GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).is_busy():
            if time.time() > timeout:
                return "error: scan timeout"
            time.sleep(5)
        
        console_output = GLOBAL_C.consoles.console(GLOBAL_CONSOLE_NUMBER).read()
        return console_output['data'] if console_output else 'no output'

    except Exception as e:
        logging.error(f"Error during Metasploit scan: {e}")
        return f"error: {str(e)}"

def scan_target(target, module_data):
    if not is_ip_reachable(target):
        print_output(f"Target {target} is not reachable", level='warning')
        return []

    nm = nmap.PortScanner()
    try:
        nm.scan(hosts=target, arguments='-p- -sV')
    except nmap.PortScannerError as e:
        print_output(f"Nmap scan error for {target}: {e}", level='error')
        return []

    results = []
    for host_ip in nm.all_hosts():
        host_result = {'ip': host_ip, 'open_ports': [], 'vulnerabilities': []}
        
        if 'tcp' in nm[host_ip]:
            for port in nm[host_ip]['tcp']:
                if nm[host_ip]['tcp'][port]['state'] == 'open':
                    host_result['open_ports'].append(port)
        
        if 445 in host_result['open_ports']:
            nm2 = nmap.PortScanner()
            try:
                nm2.scan(hosts=host_ip, arguments='-p 139,445 -sU --script smb-os-discovery')
                smb_class = smb_info_parser(host_ip, nm2)
                if smb_class and smb_class[0]:
                    host_result['smb_info'] = {
                        'os': smb_class[0].computer_os,
                        'workgroup': smb_class[0].workgroup_host,
                        'domain': smb_class[0].computer_domain,
                        'os_cpe': smb_class[0].os_cpe
                    }
            except nmap.PortScannerError as e:
                print_output(f"SMB scan error for {host_ip}: {e}", level='error')
        
        for row_i in module_data:
            console_output = msf_scan(host_ip, row_i)
            if console_output and not console_output.startswith("error"):
                vulnerability_info = {
                    'name': row_i[2] if len(row_i) > 2 else "Unknown",
                    'output': console_output
                }
                host_result['vulnerabilities'].append(vulnerability_info)
        
        results.append(host_result)
    return results

def write_results_to_file(output_file_path, all_results):
    with open(output_file_path, 'w') as output_file:
        output_file.write(text2art("RESULT", font="small"))
        output_file.write("\n")
        
        for result in all_results:
            output_file.write("=" * 50 + "\n")
            output_file.write(f"Host: {result['ip']}\n")
            output_file.write("-" * 50 + "\n")
            output_file.write(f"Open ports: {', '.join(map(str, result['open_ports']))}\n\n")
            
            if 'smb_info' in result:
                output_file.write("SMB Information:\n")
                output_file.write(f"  OS: {result['smb_info']['os']}\n")
                output_file.write(f"  Workgroup: {result['smb_info']['workgroup']}\n")
                output_file.write(f"  Domain: {result['smb_info']['domain']}\n")
                output_file.write(f"  OS CPE: {result['smb_info']['os_cpe']}\n\n")
            
            if result["vulnerabilities"]:
                output_file.write("Vulnerabilities:\n")
                for vuln in result["vulnerabilities"]:
                    output_file.write(f"  - {vuln['name']}\n")  # Name of the vulnerability
                    output_file.write(f"    Output: {vuln['output']}\n\n")
            else:
                output_file.write("No vulnerabilities detected.\n\n")
            
            output_file.write("=" * 50 + "\n\n")
            output_file.write(text2art("Aabhash", font="small"))


def main():
    '''
    Main function to orchestrate scanning process.
    '''
    try:
        print_output("Initializing Nmap scanner...", always_print=True)
        
        print_output(f"Reading input file: {ARGS.i}")
        # Read input file with subnets or IPs
        with open(ARGS.i, 'r') as input_file:
            targets = input_file.read().splitlines()

        print_output(f"Reading module file: {ARGS.l}")
        # Read module file with Metasploit modules and vulnerabilities
        with open(ARGS.l, mode='r') as csv_file:
            csv_reader = csv.reader(csv_file)
            next(csv_reader)  # Skip header row
            module_data = list(csv_reader)
        
        if not check_db_connection():
            print_output("Database connection failed. Exiting.", level='error', always_print=True)
            sys.exit(1)

        print_output(f"Writing to output file: {ARGS.o}")
        
        all_results = []
        for target in targets:
            print_output(f"Scanning target: {target}", always_print=True)
            results = scan_target(target, module_data)
            all_results.extend(results)

        # Write results to output file
        write_results_to_file(ARGS.o, all_results)

        print_output(f"Scan complete. Results saved to {ARGS.o}", level='success', always_print=True)

    except FileNotFoundError as e:
        print_output(f"Error: File not found - {e}", level='error', always_print=True)
        logging.error(f"File not found: {e}")
    except PermissionError as e:
        print_output(f"Error: Permission denied - {e}", level='error', always_print=True)
        logging.error(f"Permission denied: {e}")
    except Exception as e:
        print_output(f"An error occurred: {e}", level='error', always_print=True)
        logging.error(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
'''
IN-DEPTH VULNERABILITY SCANNER using METASPLOIT -
- AABHASH
- 22781A3746
- itsmeavron@gmail.com
'''
